{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Homepage Welcome to the documentation site for Project Books !","title":"Home"},{"location":"#homepage","text":"Welcome to the documentation site for Project Books !","title":"Homepage"},{"location":"code-of-conduct/","text":"Code of Conduct Please ensure that you remain familiar with this document as it may change from time to time. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualised language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting If someone has a problem with something that you said, please don't get defensive. Instead, stop doing what they complained about, even if you don't think you did anything wrong or if what you said was misinterpreted. It may be the case that you could have better communicated what you said. Ultimately, we're trying to make this a place where we can all get along. Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies in project spaces (e.g. the wiki, pull requests, any documentation and code) and in public spaces (such as our Slack workspace) when an individual is representing the project or its community. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project owner 1 at bookproject@madebykarankumar.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies will be posted in due course. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. For more information about how violations will be handled, see the resolutions document . Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq A part of the 'our standards' section has been adapted from the Rust code of conduct . Notes If the leadership expands to a team, this will be changed to email addresses of two different maintainers (in case the complaint is at the project owner)","title":"Code of conduct"},{"location":"code-of-conduct/#code-of-conduct","text":"Please ensure that you remain familiar with this document as it may change from time to time.","title":"Code of Conduct"},{"location":"code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualised language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting If someone has a problem with something that you said, please don't get defensive. Instead, stop doing what they complained about, even if you don't think you did anything wrong or if what you said was misinterpreted. It may be the case that you could have better communicated what you said. Ultimately, we're trying to make this a place where we can all get along.","title":"Our Standards"},{"location":"code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code-of-conduct/#scope","text":"This Code of Conduct applies in project spaces (e.g. the wiki, pull requests, any documentation and code) and in public spaces (such as our Slack workspace) when an individual is representing the project or its community.","title":"Scope"},{"location":"code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project owner 1 at bookproject@madebykarankumar.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies will be posted in due course. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. For more information about how violations will be handled, see the resolutions document .","title":"Enforcement"},{"location":"code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq A part of the 'our standards' section has been adapted from the Rust code of conduct .","title":"Attribution"},{"location":"code-of-conduct/#notes","text":"If the leadership expands to a team, this will be changed to email addresses of two different maintainers (in case the complaint is at the project owner)","title":"Notes"},{"location":"java-styleguide/","text":"Java Style guide By contributing to this repository, you are expected to follow this style guide. Please also ensure that you remain familiar with this document as it may change from time to time. Table of Contents Introduction IDE formatting IntelliJ Eclipse Checking for violations Source files American English Source file structure No wildcard imports No line-wrapping for package & import statements Fields at the top Overloads together Newline at end of file Formatting Braces One true brace style (1TBS) 100 character column limit One statement per line Empty blocks can be concise Whitespace Vertical whitespace No horizontal alignment Optional grouping parentheses: recommended Enum classes Comment fall-through Enumerate all cases or have a default case Annotations Comments Do you need the comment? Modifiers Numeric literals Underscores in numeric literals Long suffixes Variable declarations One variable declaration per line Declare as close as possible to use Arrays No C-style array declarations Indentation 4 Spaces, no tabs Aligning method calls Naming Package names Class names Method names Constant names Non-constant field names Parameter names Local variable names Type variable names Javadoc No @author tag Programming practices Annotations Use @Override Use @VisibleForTesting Don't swallow exceptions StringBuilder over StringBuffer Overriding hashCode() and equals() Overriding toString() Short methods TODOs Prefer Optional over null Favor EnumMap over HashMap JUnit tests Given/when/then pattern Fewest number of assertions in every test Assert all for multiple assertions Disabling failing tests Using DisplayName Avoid randomness Recommended reading Updates to this document Acknowledgements Introduction Good judgement should be followed. There may be times where it is more readable to not follow a particular guideline. Readable code is preferred over code that strictly follows this guide. A short summary explaining why the guideline is in place is included to help explain the rationale behind having it. IDE formatting IDE-specific code style files have been exported and can be imported into your IDE. The files are located in the ide directory. IntelliJ For IntelliJ, you can use import the code style file . Go to File > Settings > Editor > Code Style > Java in Linux or Windows. Click on the settings cog and choose Import Scheme > IntelliJ IDEA code style XML. Eclipse If you use Eclipse, you can import the formatter file by going to Window > Preferences > Java > Code Style > Formatter and selecting the import button to import the Eclipse code style file . Checking for violations We're currently using Checkstyle to check for style guide violations. To o check for any violations, you can run the following command in the root directory of the project: $ ./mvnw validate By using the maven wrapper, you don't need to have Maven installed. Alternatively, you could run mvn validate if you do have Maven installed. Source files Use American English All code and comments should be written in English (United States). Source file structure A source file should contain the following in order: License notice and copyright information Package statement Import statements Exactly one top-level class There should be exactly one blank line to separate every section. No wildcard imports Wildcard imports, regardless of whether they are static, should not be used: // good import com.vaadin.flow.component.Component; import com.vaadin.flow.component.ComponentEventListener; // bad import com.vaadin.flow.component.*; No line-wrapping for package and import statements The package statement and import statements should not be line-wrapped. Fields at the top All fields should appear at the top of the class before any constructors. Fields should not be interspersed between methods. Overloads together Overloaded methods, including constructors, should appear together with nothing in between. Newline at end of file Every source file should have one newline at the end of the file. Formatting Braces One true brace style (1TBS) We use the One true brace style (1TBS) . // bad: braces should be used even where it is optional to do so in if, else if, while and do statements if (condition) doSomething(); // good if (condition) { doSomething(); } else { doSomethingElse(); } 100 character column limit A line should generally not exceed 100 characters. Exceptions to this rule: - package and import statements - Long URL in Javadoc One statement per line A line break should follow every statement. This includes variable declarations. Empty blocks can be concise Empty blocks can be concise providing they do not form a part of a multi-block statement. // fine void foo() {} // also fine void bar() { } // not fine if (condition) { foo(); } else { } This applies to if/else and try/catch/finally blocks. Whitespace Vertical whitespace Where there should be one blank line Between the end of one method (the closing brace) and the start of another Between groups of logical statements. This could be a group of related imports, fields, or statements within a method. Generally speaking, there should not be more than one blank line. Where there should not be one blank line Between the class name and the first field declaration (or method declaration or definition) No horizontal alignment // acceptable private int numberOfPages; private String authorFirstName; // unacceptable private int numberOfPages; private String authorFirstName; There should be no horizontal alignment. While it looks nice and improves readability, it can be harder to maintain. Optional grouping parentheses: recommended Optional grouping parentheses are recommended as they can improve readability. It can help when not everyone is clear with certain precedence rules. Enum classes If an enum class has no methods, it can be written as an array initialiser: private enum EventType { SAVED, DELETED } Comment fall-through If a case continues onto the next statement group with a break , this should be commented. Something like // fall through is sufficient. For example: switch (param) { case 1: case 2: foo(); // fall through case 3: bar(); break; default: baz(); } The final statement in the switch block, the default case above, does not require a fall-through comment. Enumerate all cases or have a default case Either cover all of the cases or use the default case. Covering all cases is the preferred approach. Annotations Annotations should appear after any javadoc for the class, field or method. Each annotation should appear on its own line. For example: @Override @Nullable public Integer getPagesReadIfPresent() { ... } However, for fields, multiple annotations can be on the same line: @NotNull @VisibleForTesting String authorFirstName; Comments This section is to do with implementation comments, not Javadoc. Comments should not be decorated with asterisks or any other characters. Do you need the comment? Only add comments where they add value. Comments should be used as a last resort. We prefer to make code readable by making the code trivial such that having a comment is redundant. Alternatively, we prefer to extract code into a method with a descriptive method name such that the method name makes the comment redundant. Modifiers Where applicable, class and member modifiers should appear in the following order, as recommended by the Java Language Specification: public protected private abstract default static final transient volatile synchronized native strictfp Numeric literals Underscores in numeric literals For numeric literals that are ten thousand or higher, underscores are recommended to separate digits by thousands: // bad int booksSold = 10000; // good int booksSold = 10_000; Long suffixes long variables should be suffixed with an uppercase L . The lowercase l should not be used as it may cause confusion with the digit 1 . For example, 1_000_000_000L instead of 1_000_000_000l . Variable declarations One variable declaration per line A variable declaration should appear on its own line. There should not be multiple declarations on one line: // good private String authorFirstName; private String authorLastName; // bad private String authorFirstName, authorLastName; Declare as close as possible to use Local variables should be declared as close as reasonably possible to where it is used. This can help limit the scope and improve readability. Local variables should not be declared at the top of a method for the sake of it. Arrays No C-style array declarations The square brackets should be next to the type name, not the variable name. This is because they a part of the type. // good String[] args // bad String args[] Indentation 4 Spaces, no tabs Four spaces should be used for indentation. This is clearer than two spaces (more than four is extraneous). This also applies to CSS. Aligning method calls An exception to the above four spaces indentation rule is aligning method calls (see below). This can improve readability. // good bookGrid.addColumn(AUTHOR_KEY) .setSortable(true); // bad bookGrid.addColumn(AUTHOR_KEY) .setSortable(true); Naming Special prefixes or suffixes, such as to represent member variables, are not used. For example, the following are not permitted: mTitle and _title . Package names Package names are written in lowercase. Consecutive words are concatenated together without any underscores. For example, com.example.readinggoal , not com.example.readingGoal or com.example.reading_goal . To aid readability, try to keep package names short and one-word names wherever possible. Class names Class names are written in PascalCase (also referred to as UpperCamelCase). Class names should be nouns or noun phrases. Interface names can be nouns or noun phrases. However, in some cases, adjectives or adjective phrases are better (e.g. Iterable ). Test classes should be the name of the class that it is testing followed by the suffix Test . For example. the test class for the GenreStatistics class should be called GenreStatisticsTest . Method names Method names are written in lowerCamelCase. Method names should usually be verb or verb phrases. For example, processTransaction or findId . Underscores are allowed in JUnit test methods to separate logical components. One popular pattern is <methodUnderTest>_<state> ; for example, pop_emptyStack . The most important thing is that the test method name clearly summarises what is being tested. Constant names Constants are written in CONSTANT_CASE. It is written in uppercase letters with each word separated by an underscore. Non-constant field names Non-constant field names, regardless of whether they are static, are written in lowerCamelCase . The names tend to be noun or noun phrases. Parameter names Parameter names are written in lowerCamelCase . Single letter parameter names should be avoided in methods (common exception: for loops). Local variables names Local variables names are written in lowerCamelCase . Even if they are immutable (e.g. marked as final ), they are not considered constants, so they are not styled as constants. Type variables names Type variables should be either: - One capital letter, which can be optionally succeeded by a letter (e.g. T , E or T2 ) - A class name followed by the capital letter T (e.g. AuthorT ) Javadoc No @author tag Author tags can quickly become outdated as methods are updated or completely written by new authors. Git is far better at tracking changes. Programming practices Annotations Use @Override The @Override annotation should be used for overridden methods. This is so that the compiler can run a check at compile-time to see whether the method annotated with @Override actually overrides a method. Use @VisibleForTesting While it is usually better to limit members and methods, if it's required for testing, it will need to be made package-private. In such cases, they should be tagged as @VisibleForTesting to make it clear. Don't swallow exceptions Rarely should there be no response to a caught exception (e.g. you may want to log it). If it is right not to do anything, then this has to be justified in a comment. An exception to ignore exceptions is if the exception is expected in a test. For example, you may want to test whether the code under test does indeed throw an exception: try { foo(-1); } catch (IndexOutOfBoundsException expected) { } In such cases, the exception parameter should be called or include the word expected , as above. StringBuilder over StringBuffer StringBuilder should be used instead of a StringBuffer for single-threaded code. Overriding hashCode() and equals() If you override hashCode() , it is good practice to also override equals() . The overrides of equals() and hashCode() should be equivalent; if x.equals(y) is true, then x.hashCode() should have the same value as y.hashCode() . Overriding toString() It is sometimes worthwhile overriding toString() for logging purposes. // OK, but could be better. The hardcoded class name has to be changed if the class name changes @Override public String toString() { return \"Book[title= \" + title + \", published = \" + published + \"]\" ; } // Better @Override public String toString() { return getClass.getName() + \"[title= \" + title + \", published = \" + published + \"]\" ; } Short methods Wherever possible, try to keep methods short (under 15 lines). This makes it easier to test, comprehend and reuse. TODOs TODO comments are acceptable and encouraged if they are useful. However, we ask that if you create a TODO, please also create a new corresponding issue. Prefer Optional over null Optional provides useful semantics that something may be null . If you need to use null s, consider using Optional s instead. Favor EnumMap over HashMap For enums, favor EnumMap over HashMap for performance reasons . JUnit tests Use AssertJ For assertions and assumptions, we're using AssertJ. We find this to be more readable (it flows nicer as it reads like a sentence) and it's easier to have a consistent team style. Given/when/then pattern The pattern we follow for JUnit tests are given/when/then. For example, given some input some setup, when an action occurs, then assert as desired. Concrete example: @Test void errorShownWhenEmailInUse() { // given userRepository.save(VALID_TEST_USER); EmailField emailField = _get(EmailField.class, spec -> spec.withId(\"email\")); // when _setValue(emailField, VALID_TEST_USER.getEmail()); // then assertThat(emailField.getErrorMessage()).isNotBlank(); } In general, we add comments to separate out the given, when and then sections. We find that this greatly improves readability. Fewest number of assertions in every test In every test method, try to minimise the number of assertions. Ideally, there should only be one. Assert all for multiple assertions If a test method needs multiple assertions, assertSoftly() should be used. Otherwise, lazy evaluation is used. For example, if you had two assertions, and both assertions fail, you will not know about the second assertion failing until you have fixed the first assertion. No disabling failing tests If a test fails, you are generally expected to fix it. We generally prefer for builds to fail rather than commenting out or disabling tests wtih the @Disable annotation. Using DisplayName All test classes should be annotated with a @DisplayName . For example, the test class TagServiceTest should be annotated with the display name TagService should . We find this greatly improves readability as the method names can be read like a sentence (e.g. TagService should findAllTags() or deleteExistingTag() ). A @DisplayName annotation should be used at a method level where it adds value. For example, you could replace a Javadoc comment with a display name. This is also useful if the method name is concise but not comprehensive. Adding a display name should be used where it serves as useful documentation. Avoid randomness While it may seem better to use pseudorandom bounded values so that you can test more cases, it rarely improves coverage. It's better to use fixed input data with well-defined edge cases. Recommended reading Clean code, Robert C. Martin Updates to this document If you change any of the recommended styles in this guide, please note that the following may also need to be changed: Checkstyle configuration IntelliJ formatter Eclipse formatter In addition, please update the table of contents. Acknowledgements This style guide has been adapted from Google's Java style guide and Twitter's common style guide .","title":"Java styleguide"},{"location":"java-styleguide/#java-style-guide","text":"By contributing to this repository, you are expected to follow this style guide. Please also ensure that you remain familiar with this document as it may change from time to time.","title":"Java Style guide"},{"location":"java-styleguide/#table-of-contents","text":"Introduction IDE formatting IntelliJ Eclipse Checking for violations Source files American English Source file structure No wildcard imports No line-wrapping for package & import statements Fields at the top Overloads together Newline at end of file Formatting Braces One true brace style (1TBS) 100 character column limit One statement per line Empty blocks can be concise Whitespace Vertical whitespace No horizontal alignment Optional grouping parentheses: recommended Enum classes Comment fall-through Enumerate all cases or have a default case Annotations Comments Do you need the comment? Modifiers Numeric literals Underscores in numeric literals Long suffixes Variable declarations One variable declaration per line Declare as close as possible to use Arrays No C-style array declarations Indentation 4 Spaces, no tabs Aligning method calls Naming Package names Class names Method names Constant names Non-constant field names Parameter names Local variable names Type variable names Javadoc No @author tag Programming practices Annotations Use @Override Use @VisibleForTesting Don't swallow exceptions StringBuilder over StringBuffer Overriding hashCode() and equals() Overriding toString() Short methods TODOs Prefer Optional over null Favor EnumMap over HashMap JUnit tests Given/when/then pattern Fewest number of assertions in every test Assert all for multiple assertions Disabling failing tests Using DisplayName Avoid randomness Recommended reading Updates to this document Acknowledgements","title":"Table of Contents"},{"location":"java-styleguide/#introduction","text":"Good judgement should be followed. There may be times where it is more readable to not follow a particular guideline. Readable code is preferred over code that strictly follows this guide. A short summary explaining why the guideline is in place is included to help explain the rationale behind having it.","title":"Introduction"},{"location":"java-styleguide/#ide-formatting","text":"IDE-specific code style files have been exported and can be imported into your IDE. The files are located in the ide directory.","title":"IDE formatting"},{"location":"java-styleguide/#intellij","text":"For IntelliJ, you can use import the code style file . Go to File > Settings > Editor > Code Style > Java in Linux or Windows. Click on the settings cog and choose Import Scheme > IntelliJ IDEA code style XML.","title":"IntelliJ"},{"location":"java-styleguide/#eclipse","text":"If you use Eclipse, you can import the formatter file by going to Window > Preferences > Java > Code Style > Formatter and selecting the import button to import the Eclipse code style file .","title":"Eclipse"},{"location":"java-styleguide/#checking-for-violations","text":"We're currently using Checkstyle to check for style guide violations. To o check for any violations, you can run the following command in the root directory of the project: $ ./mvnw validate By using the maven wrapper, you don't need to have Maven installed. Alternatively, you could run mvn validate if you do have Maven installed.","title":"Checking for violations"},{"location":"java-styleguide/#source-files","text":"","title":"Source files"},{"location":"java-styleguide/#use-american-english","text":"All code and comments should be written in English (United States).","title":"Use American English"},{"location":"java-styleguide/#source-file-structure","text":"A source file should contain the following in order: License notice and copyright information Package statement Import statements Exactly one top-level class There should be exactly one blank line to separate every section.","title":"Source file structure"},{"location":"java-styleguide/#no-wildcard-imports","text":"Wildcard imports, regardless of whether they are static, should not be used: // good import com.vaadin.flow.component.Component; import com.vaadin.flow.component.ComponentEventListener; // bad import com.vaadin.flow.component.*;","title":"No wildcard imports"},{"location":"java-styleguide/#no-line-wrapping-for-package-and-import-statements","text":"The package statement and import statements should not be line-wrapped.","title":"No line-wrapping for package and import statements"},{"location":"java-styleguide/#fields-at-the-top","text":"All fields should appear at the top of the class before any constructors. Fields should not be interspersed between methods.","title":"Fields at the top"},{"location":"java-styleguide/#overloads-together","text":"Overloaded methods, including constructors, should appear together with nothing in between.","title":"Overloads together"},{"location":"java-styleguide/#newline-at-end-of-file","text":"Every source file should have one newline at the end of the file.","title":"Newline at end of file"},{"location":"java-styleguide/#formatting","text":"","title":"Formatting"},{"location":"java-styleguide/#braces","text":"","title":"Braces"},{"location":"java-styleguide/#one-true-brace-style-1tbs","text":"We use the One true brace style (1TBS) . // bad: braces should be used even where it is optional to do so in if, else if, while and do statements if (condition) doSomething(); // good if (condition) { doSomething(); } else { doSomethingElse(); }","title":"One true brace style (1TBS)"},{"location":"java-styleguide/#100-character-column-limit","text":"A line should generally not exceed 100 characters. Exceptions to this rule: - package and import statements - Long URL in Javadoc","title":"100 character column limit"},{"location":"java-styleguide/#one-statement-per-line","text":"A line break should follow every statement. This includes variable declarations.","title":"One statement per line"},{"location":"java-styleguide/#empty-blocks-can-be-concise","text":"Empty blocks can be concise providing they do not form a part of a multi-block statement. // fine void foo() {} // also fine void bar() { } // not fine if (condition) { foo(); } else { } This applies to if/else and try/catch/finally blocks.","title":"Empty blocks can be concise"},{"location":"java-styleguide/#whitespace","text":"","title":"Whitespace"},{"location":"java-styleguide/#vertical-whitespace","text":"Where there should be one blank line Between the end of one method (the closing brace) and the start of another Between groups of logical statements. This could be a group of related imports, fields, or statements within a method. Generally speaking, there should not be more than one blank line. Where there should not be one blank line Between the class name and the first field declaration (or method declaration or definition)","title":"Vertical whitespace"},{"location":"java-styleguide/#no-horizontal-alignment","text":"// acceptable private int numberOfPages; private String authorFirstName; // unacceptable private int numberOfPages; private String authorFirstName; There should be no horizontal alignment. While it looks nice and improves readability, it can be harder to maintain.","title":"No horizontal alignment"},{"location":"java-styleguide/#optional-grouping-parentheses-recommended","text":"Optional grouping parentheses are recommended as they can improve readability. It can help when not everyone is clear with certain precedence rules.","title":"Optional grouping parentheses: recommended"},{"location":"java-styleguide/#enum-classes","text":"If an enum class has no methods, it can be written as an array initialiser: private enum EventType { SAVED, DELETED }","title":"Enum classes"},{"location":"java-styleguide/#comment-fall-through","text":"If a case continues onto the next statement group with a break , this should be commented. Something like // fall through is sufficient. For example: switch (param) { case 1: case 2: foo(); // fall through case 3: bar(); break; default: baz(); } The final statement in the switch block, the default case above, does not require a fall-through comment.","title":"Comment fall-through"},{"location":"java-styleguide/#enumerate-all-cases-or-have-a-default-case","text":"Either cover all of the cases or use the default case. Covering all cases is the preferred approach.","title":"Enumerate all cases or have a default case"},{"location":"java-styleguide/#annotations","text":"Annotations should appear after any javadoc for the class, field or method. Each annotation should appear on its own line. For example: @Override @Nullable public Integer getPagesReadIfPresent() { ... } However, for fields, multiple annotations can be on the same line: @NotNull @VisibleForTesting String authorFirstName;","title":"Annotations"},{"location":"java-styleguide/#comments","text":"This section is to do with implementation comments, not Javadoc. Comments should not be decorated with asterisks or any other characters.","title":"Comments"},{"location":"java-styleguide/#do-you-need-the-comment","text":"Only add comments where they add value. Comments should be used as a last resort. We prefer to make code readable by making the code trivial such that having a comment is redundant. Alternatively, we prefer to extract code into a method with a descriptive method name such that the method name makes the comment redundant.","title":"Do you need the comment?"},{"location":"java-styleguide/#modifiers","text":"Where applicable, class and member modifiers should appear in the following order, as recommended by the Java Language Specification: public protected private abstract default static final transient volatile synchronized native strictfp","title":"Modifiers"},{"location":"java-styleguide/#numeric-literals","text":"","title":"Numeric literals"},{"location":"java-styleguide/#underscores-in-numeric-literals","text":"For numeric literals that are ten thousand or higher, underscores are recommended to separate digits by thousands: // bad int booksSold = 10000; // good int booksSold = 10_000;","title":"Underscores in numeric literals"},{"location":"java-styleguide/#long-suffixes","text":"long variables should be suffixed with an uppercase L . The lowercase l should not be used as it may cause confusion with the digit 1 . For example, 1_000_000_000L instead of 1_000_000_000l .","title":"Long suffixes"},{"location":"java-styleguide/#variable-declarations","text":"","title":"Variable declarations"},{"location":"java-styleguide/#one-variable-declaration-per-line","text":"A variable declaration should appear on its own line. There should not be multiple declarations on one line: // good private String authorFirstName; private String authorLastName; // bad private String authorFirstName, authorLastName;","title":"One variable declaration per line"},{"location":"java-styleguide/#declare-as-close-as-possible-to-use","text":"Local variables should be declared as close as reasonably possible to where it is used. This can help limit the scope and improve readability. Local variables should not be declared at the top of a method for the sake of it.","title":"Declare as close as possible to use"},{"location":"java-styleguide/#arrays","text":"","title":"Arrays"},{"location":"java-styleguide/#no-c-style-array-declarations","text":"The square brackets should be next to the type name, not the variable name. This is because they a part of the type. // good String[] args // bad String args[]","title":"No C-style array declarations"},{"location":"java-styleguide/#indentation","text":"","title":"Indentation"},{"location":"java-styleguide/#4-spaces-no-tabs","text":"Four spaces should be used for indentation. This is clearer than two spaces (more than four is extraneous). This also applies to CSS.","title":"4 Spaces, no tabs"},{"location":"java-styleguide/#aligning-method-calls","text":"An exception to the above four spaces indentation rule is aligning method calls (see below). This can improve readability. // good bookGrid.addColumn(AUTHOR_KEY) .setSortable(true); // bad bookGrid.addColumn(AUTHOR_KEY) .setSortable(true);","title":"Aligning method calls"},{"location":"java-styleguide/#naming","text":"Special prefixes or suffixes, such as to represent member variables, are not used. For example, the following are not permitted: mTitle and _title .","title":"Naming"},{"location":"java-styleguide/#package-names","text":"Package names are written in lowercase. Consecutive words are concatenated together without any underscores. For example, com.example.readinggoal , not com.example.readingGoal or com.example.reading_goal . To aid readability, try to keep package names short and one-word names wherever possible.","title":"Package names"},{"location":"java-styleguide/#class-names","text":"Class names are written in PascalCase (also referred to as UpperCamelCase). Class names should be nouns or noun phrases. Interface names can be nouns or noun phrases. However, in some cases, adjectives or adjective phrases are better (e.g. Iterable ). Test classes should be the name of the class that it is testing followed by the suffix Test . For example. the test class for the GenreStatistics class should be called GenreStatisticsTest .","title":"Class names"},{"location":"java-styleguide/#method-names","text":"Method names are written in lowerCamelCase. Method names should usually be verb or verb phrases. For example, processTransaction or findId . Underscores are allowed in JUnit test methods to separate logical components. One popular pattern is <methodUnderTest>_<state> ; for example, pop_emptyStack . The most important thing is that the test method name clearly summarises what is being tested.","title":"Method names"},{"location":"java-styleguide/#constant-names","text":"Constants are written in CONSTANT_CASE. It is written in uppercase letters with each word separated by an underscore.","title":"Constant names"},{"location":"java-styleguide/#non-constant-field-names","text":"Non-constant field names, regardless of whether they are static, are written in lowerCamelCase . The names tend to be noun or noun phrases.","title":"Non-constant field names"},{"location":"java-styleguide/#parameter-names","text":"Parameter names are written in lowerCamelCase . Single letter parameter names should be avoided in methods (common exception: for loops).","title":"Parameter names"},{"location":"java-styleguide/#local-variables-names","text":"Local variables names are written in lowerCamelCase . Even if they are immutable (e.g. marked as final ), they are not considered constants, so they are not styled as constants.","title":"Local variables names"},{"location":"java-styleguide/#type-variables-names","text":"Type variables should be either: - One capital letter, which can be optionally succeeded by a letter (e.g. T , E or T2 ) - A class name followed by the capital letter T (e.g. AuthorT )","title":"Type variables names"},{"location":"java-styleguide/#javadoc","text":"","title":"Javadoc"},{"location":"java-styleguide/#no-author-tag","text":"Author tags can quickly become outdated as methods are updated or completely written by new authors. Git is far better at tracking changes.","title":"No @author tag"},{"location":"java-styleguide/#programming-practices","text":"","title":"Programming practices"},{"location":"java-styleguide/#annotations_1","text":"","title":"Annotations"},{"location":"java-styleguide/#use-override","text":"The @Override annotation should be used for overridden methods. This is so that the compiler can run a check at compile-time to see whether the method annotated with @Override actually overrides a method.","title":"Use @Override"},{"location":"java-styleguide/#use-visiblefortesting","text":"While it is usually better to limit members and methods, if it's required for testing, it will need to be made package-private. In such cases, they should be tagged as @VisibleForTesting to make it clear.","title":"Use @VisibleForTesting"},{"location":"java-styleguide/#dont-swallow-exceptions","text":"Rarely should there be no response to a caught exception (e.g. you may want to log it). If it is right not to do anything, then this has to be justified in a comment. An exception to ignore exceptions is if the exception is expected in a test. For example, you may want to test whether the code under test does indeed throw an exception: try { foo(-1); } catch (IndexOutOfBoundsException expected) { } In such cases, the exception parameter should be called or include the word expected , as above.","title":"Don't swallow exceptions"},{"location":"java-styleguide/#stringbuilder-over-stringbuffer","text":"StringBuilder should be used instead of a StringBuffer for single-threaded code.","title":"StringBuilder over StringBuffer"},{"location":"java-styleguide/#overriding-hashcode-and-equals","text":"If you override hashCode() , it is good practice to also override equals() . The overrides of equals() and hashCode() should be equivalent; if x.equals(y) is true, then x.hashCode() should have the same value as y.hashCode() .","title":"Overriding hashCode() and equals()"},{"location":"java-styleguide/#overriding-tostring","text":"It is sometimes worthwhile overriding toString() for logging purposes. // OK, but could be better. The hardcoded class name has to be changed if the class name changes @Override public String toString() { return \"Book[title= \" + title + \", published = \" + published + \"]\" ; } // Better @Override public String toString() { return getClass.getName() + \"[title= \" + title + \", published = \" + published + \"]\" ; }","title":"Overriding toString()"},{"location":"java-styleguide/#short-methods","text":"Wherever possible, try to keep methods short (under 15 lines). This makes it easier to test, comprehend and reuse.","title":"Short methods"},{"location":"java-styleguide/#todos","text":"TODO comments are acceptable and encouraged if they are useful. However, we ask that if you create a TODO, please also create a new corresponding issue.","title":"TODOs"},{"location":"java-styleguide/#prefer-optional-over-null","text":"Optional provides useful semantics that something may be null . If you need to use null s, consider using Optional s instead.","title":"Prefer Optional over null"},{"location":"java-styleguide/#favor-enummap-over-hashmap","text":"For enums, favor EnumMap over HashMap for performance reasons .","title":"Favor EnumMap over HashMap"},{"location":"java-styleguide/#junit-tests","text":"","title":"JUnit tests"},{"location":"java-styleguide/#use-assertj","text":"For assertions and assumptions, we're using AssertJ. We find this to be more readable (it flows nicer as it reads like a sentence) and it's easier to have a consistent team style.","title":"Use AssertJ"},{"location":"java-styleguide/#givenwhenthen-pattern","text":"The pattern we follow for JUnit tests are given/when/then. For example, given some input some setup, when an action occurs, then assert as desired. Concrete example: @Test void errorShownWhenEmailInUse() { // given userRepository.save(VALID_TEST_USER); EmailField emailField = _get(EmailField.class, spec -> spec.withId(\"email\")); // when _setValue(emailField, VALID_TEST_USER.getEmail()); // then assertThat(emailField.getErrorMessage()).isNotBlank(); } In general, we add comments to separate out the given, when and then sections. We find that this greatly improves readability.","title":"Given/when/then pattern"},{"location":"java-styleguide/#fewest-number-of-assertions-in-every-test","text":"In every test method, try to minimise the number of assertions. Ideally, there should only be one.","title":"Fewest number of assertions in every test"},{"location":"java-styleguide/#assert-all-for-multiple-assertions","text":"If a test method needs multiple assertions, assertSoftly() should be used. Otherwise, lazy evaluation is used. For example, if you had two assertions, and both assertions fail, you will not know about the second assertion failing until you have fixed the first assertion.","title":"Assert all for multiple assertions"},{"location":"java-styleguide/#no-disabling-failing-tests","text":"If a test fails, you are generally expected to fix it. We generally prefer for builds to fail rather than commenting out or disabling tests wtih the @Disable annotation.","title":"No disabling failing tests"},{"location":"java-styleguide/#using-displayname","text":"All test classes should be annotated with a @DisplayName . For example, the test class TagServiceTest should be annotated with the display name TagService should . We find this greatly improves readability as the method names can be read like a sentence (e.g. TagService should findAllTags() or deleteExistingTag() ). A @DisplayName annotation should be used at a method level where it adds value. For example, you could replace a Javadoc comment with a display name. This is also useful if the method name is concise but not comprehensive. Adding a display name should be used where it serves as useful documentation.","title":"Using DisplayName"},{"location":"java-styleguide/#avoid-randomness","text":"While it may seem better to use pseudorandom bounded values so that you can test more cases, it rarely improves coverage. It's better to use fixed input data with well-defined edge cases.","title":"Avoid randomness"},{"location":"java-styleguide/#recommended-reading","text":"Clean code, Robert C. Martin","title":"Recommended reading"},{"location":"java-styleguide/#updates-to-this-document","text":"If you change any of the recommended styles in this guide, please note that the following may also need to be changed: Checkstyle configuration IntelliJ formatter Eclipse formatter In addition, please update the table of contents.","title":"Updates to this document"},{"location":"java-styleguide/#acknowledgements","text":"This style guide has been adapted from Google's Java style guide and Twitter's common style guide .","title":"Acknowledgements"},{"location":"react-styleguide/","text":"React Style guide By contributing to this repository, you are expected to follow this style guide. Please also ensure that you remain familiar with this document as it may change from time to time. Introduction Good judgement should be followed. There may be times where it is more readable to not follow a particular guideline. Readable code is preferred over code that strictly follows this guide. Where useful, a short summary explaining why the guideline is in place is included to help explain the rationale behind having it. Fundamental rules Only have one React component per file But mutliple stateless components are allowed per file Always use JSX syntax Files All source files should start with our copyright notice attached verbatim. Class vs. React.createClass Use class extends React.Component if you have internal state. Otherwise, use regular functions (not arrow functions) Naming File extension : use the .tsx extension for React components File names : Use PascalCase for file names Component names Use the file name for the component name camelCase prop names : Use camelCase for prop names Avoid DOM component prop names : avoid using DOM component prop names for a different purpose Ordering Ordering for a class that extends React.Component : constructor componentDidMount componentWillUpdate componentWillUnmount render Additional render methods (e.g. renderHeader ) Spacing Always have one space before the self-closing tag <Component/> // bad <Component /> // also bad (more than one space) <Component /> // good Do not pad JSX curly braces with spaces <Component props={ something }> // bad <Component props={something}> // good Parentheses Wrap JSX tags in parentheses if they span more than one line // bad render() { return <Component> <ChildComponent /> </Component>; } // good render() { return ( <Component> <ChildComponent /> </Component> ) } // also good when only one line render() { return <Component>{some text}</Component> } Acknowledgments Adapted from Airbnb's React/JSX style guide .","title":"React styleguide"},{"location":"react-styleguide/#react-style-guide","text":"By contributing to this repository, you are expected to follow this style guide. Please also ensure that you remain familiar with this document as it may change from time to time.","title":"React  Style guide"},{"location":"react-styleguide/#introduction","text":"Good judgement should be followed. There may be times where it is more readable to not follow a particular guideline. Readable code is preferred over code that strictly follows this guide. Where useful, a short summary explaining why the guideline is in place is included to help explain the rationale behind having it.","title":"Introduction"},{"location":"react-styleguide/#fundamental-rules","text":"Only have one React component per file But mutliple stateless components are allowed per file Always use JSX syntax","title":"Fundamental rules"},{"location":"react-styleguide/#files","text":"All source files should start with our copyright notice attached verbatim.","title":"Files"},{"location":"react-styleguide/#class-vs-reactcreateclass","text":"Use class extends React.Component if you have internal state. Otherwise, use regular functions (not arrow functions)","title":"Class vs. React.createClass"},{"location":"react-styleguide/#naming","text":"File extension : use the .tsx extension for React components File names : Use PascalCase for file names Component names Use the file name for the component name camelCase prop names : Use camelCase for prop names Avoid DOM component prop names : avoid using DOM component prop names for a different purpose","title":"Naming"},{"location":"react-styleguide/#ordering","text":"Ordering for a class that extends React.Component : constructor componentDidMount componentWillUpdate componentWillUnmount render Additional render methods (e.g. renderHeader )","title":"Ordering"},{"location":"react-styleguide/#spacing","text":"Always have one space before the self-closing tag <Component/> // bad <Component /> // also bad (more than one space) <Component /> // good Do not pad JSX curly braces with spaces <Component props={ something }> // bad <Component props={something}> // good","title":"Spacing"},{"location":"react-styleguide/#parentheses","text":"Wrap JSX tags in parentheses if they span more than one line // bad render() { return <Component> <ChildComponent /> </Component>; } // good render() { return ( <Component> <ChildComponent /> </Component> ) } // also good when only one line render() { return <Component>{some text}</Component> }","title":"Parentheses"},{"location":"react-styleguide/#acknowledgments","text":"Adapted from Airbnb's React/JSX style guide .","title":"Acknowledgments"},{"location":"typescript-styleguide/","text":"TypeScript Style guide By contributing to this repository, you are expected to follow this style guide. Please also ensure that you remain familiar with this document as it may change from time to time. Multiple versions of this style guide may exist throughout this repository. As with other documents on this repository, the version on the master branch should be followed, as this version should be the most up-to-date. This also encompasses our JavaScript style. Introduction Good judgement should be followed. There may be times where it is more readable to not follow a particular guideline. Readable code is preferred over code that strictly follows this guide. Where useful, a short summary explaining why the guideline is in place is included to help explain the rationale behind having it. Please note that we're using Yarn as our package manager, not npm. Files Include copyright notice All source files should start with our copyright notice attached verbatim. Formatting Lines should generally not exceed our 100 characters column limit. This is to be consistent with our Java style guide. Braces One true brace style (1TBS) We use the One true brace style (1TBS) . // bad: braces should be used even where it is optional to do so in if, else if, while and do statements if (condition) doSomething(); // good if (condition) { doSomething(); } else { doSomethingElse(); } Language Avoid using var . Instead, prefer const and let No wildcard imports (so we have one export per file) Naming Method names Method names should be written in camelCase and be be verb or verb phrases. Enum names Enum names should be written in PascalCase . Enum items are written in CONSTANT_CASE . Parameter names Parameter names should be written in camcelCase . Local variable names Local variable names should be written in camelCase even where they are constants. Acknowledgements Adapted from Google's JavaScript style guide and Airbnb's JavaScript style guide .","title":"TypeScript styleguide"},{"location":"typescript-styleguide/#typescript-style-guide","text":"By contributing to this repository, you are expected to follow this style guide. Please also ensure that you remain familiar with this document as it may change from time to time. Multiple versions of this style guide may exist throughout this repository. As with other documents on this repository, the version on the master branch should be followed, as this version should be the most up-to-date. This also encompasses our JavaScript style.","title":"TypeScript Style guide"},{"location":"typescript-styleguide/#introduction","text":"Good judgement should be followed. There may be times where it is more readable to not follow a particular guideline. Readable code is preferred over code that strictly follows this guide. Where useful, a short summary explaining why the guideline is in place is included to help explain the rationale behind having it. Please note that we're using Yarn as our package manager, not npm.","title":"Introduction"},{"location":"typescript-styleguide/#files","text":"","title":"Files"},{"location":"typescript-styleguide/#include-copyright-notice","text":"All source files should start with our copyright notice attached verbatim.","title":"Include copyright notice"},{"location":"typescript-styleguide/#formatting","text":"Lines should generally not exceed our 100 characters column limit. This is to be consistent with our Java style guide.","title":"Formatting"},{"location":"typescript-styleguide/#braces","text":"","title":"Braces"},{"location":"typescript-styleguide/#one-true-brace-style-1tbs","text":"We use the One true brace style (1TBS) . // bad: braces should be used even where it is optional to do so in if, else if, while and do statements if (condition) doSomething(); // good if (condition) { doSomething(); } else { doSomethingElse(); }","title":"One true brace style (1TBS)"},{"location":"typescript-styleguide/#language","text":"Avoid using var . Instead, prefer const and let No wildcard imports (so we have one export per file)","title":"Language"},{"location":"typescript-styleguide/#naming","text":"","title":"Naming"},{"location":"typescript-styleguide/#method-names","text":"Method names should be written in camelCase and be be verb or verb phrases.","title":"Method names"},{"location":"typescript-styleguide/#enum-names","text":"Enum names should be written in PascalCase . Enum items are written in CONSTANT_CASE .","title":"Enum names"},{"location":"typescript-styleguide/#parameter-names","text":"Parameter names should be written in camcelCase .","title":"Parameter names"},{"location":"typescript-styleguide/#local-variable-names","text":"Local variable names should be written in camelCase even where they are constants.","title":"Local variable names"},{"location":"typescript-styleguide/#acknowledgements","text":"Adapted from Google's JavaScript style guide and Airbnb's JavaScript style guide .","title":"Acknowledgements"}]}